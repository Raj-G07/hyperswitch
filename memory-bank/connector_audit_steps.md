# Connector Audit Steps

This document outlines the general steps to perform an audit of a connector. This guide is intended to be a reference for auditing any connector, ensuring consistency and accuracy.

## 1. Understand the Connector's Workflow

*   **Identify Key Features:** Determine the core functionalities supported by the connector (e.g., Authorize , PSync , Capture, Void, Refund, RSync,Complete Authorize, Webhooks).
*   **Review Documentation:** If available, read the connector's documentation to understand its intended behavior and data flow.

## 2. Examine the Connector's Code

*   **Locate Relevant Files:** Identify the files responsible for handling responses from the connector and mapping them to Hyperswitch's internal representations.
    *   Typically, these files are named `transformers.rs` or similar, and reside within the connector's directory (e.g., `crates/hyperswitch_connectors/src/connectors/[connector_name]/`).

                                         <!-- ----------------------------------------------------- -->

## Status Mapping Audit

### 3. Inspect Status Mapping

*   Analyze the code that maps the connector's status to Hyperswitch's `AttemptStatus` and `RefundStatus` enums, also check if any other is there.
    *   Look for `From` implementations or similar mapping logic.
    *   Verify that all possible connector statuses are handled and mapped correctly to the appropriate Hyperswitch status.

### 4. Tools and Techniques for Status Mapping

*   **`read_file`:** Use this tool to examine the contents of the connector's code files (e.g., `transformers.rs`, `response.rs`).
*   **`search_files`:** Use this tool to search for specific code patterns or keywords within the connector's directory.
    *   Example: `search_files <path>crates/hyperswitch_connectors/src/connectors/[connector_name]</path> <regex>From<[ConnectorPaymentStatus]> for common_enums::(AttemptStatus|RefundStatus)</regex>`
*   **Manual Analysis:** Carefully review the code to understand the data flow and mapping logic.

### 5. Common Errors and Corrections for Status Mapping

*   **Incorrect Status Mapping:** Mapping a connector status to the wrong Hyperswitch status can lead to incorrect payment processing and reporting.
    *   **Correction:** Verify the intended meaning of each connector status and map it to the corresponding Hyperswitch status.
*   **Incomplete Status Mapping:** Failing to handle all possible connector statuses can lead to unexpected behavior.
    *   **Correction:** Ensure that all possible connector statuses are mapped to a corresponding Hyperswitch status, including error cases.

### 6. Example: GlobalPay Connector Status Mapping Audit

In the GlobalPay connector audit, the following steps were taken:

1.  The `crates/hyperswitch_connectors/src/connectors/globalpay/transformers.rs` file was examined to understand the status mapping.
2.  The `From` implementations for `GlobalpayPaymentStatus` to `common_enums::AttemptStatus` and `common_enums::RefundStatus` were analyzed to verify the status mapping.
3.  The `memory-bank/GlobalPay_connector.md` file was updated with the audit results.

                                         <!-- ----------------------------------------------------- -->

## Reference ID Reconciliation Audit

### 7. Inspect Reference ID Handling

*   Identify how the connector's transaction IDs and reference IDs are extracted from the request and response and mapped to Hyperswitch's `connector_request_reference_id`, `connector_response_reference_id` and `connector_transaction_id` fields.
    *   Ensure that the correct fields are being used for reconciliation purposes. The `connector_transaction_id` should contain a unique identifier generated by the connector, while the `connector_response_reference_id` may contain a merchant-defined reference.

### 8. Tools and Techniques for Reference ID Reconciliation

*   **`read_file`:** Use this tool to examine the contents of the connector's code files (e.g., `transformers.rs`, `response.rs`).
*   **`search_files`:** Use this tool to search for specific code patterns or keywords within the connector's directory.
    *   Example: `search_files <path>crates/hyperswitch_connectors/src/connectors/[connector_name]</path> <regex>connector_transaction_id: Some\(response\.(.*)\)</regex>`
*   **Manual Analysis:** Carefully review the code to understand the data flow and mapping logic.

### 9. Common Errors and Corrections for Reference ID Reconciliation

*   **Incorrect Reference ID Handling:** Using the wrong field for `connector_transaction_id` or `connector_response_reference_id` can cause reconciliation issues.
    *   **Correction:** Identify the correct field in the connector's response that uniquely identifies the transaction and use it for `connector_transaction_id`. The `connector_response_reference_id` should be populated with the merchant-defined reference, if available.

### 10. Example: GlobalPay Connector Reference ID Reconciliation Audit

In the GlobalPay connector audit, the following steps were taken:

1.  The `crates/hyperswitch_connectors/src/connectors/globalpay.rs` file was examined to understand how the connector handles `connector_request_reference_id` and `connector_response_reference_id`.
2.  The `crates/hyperswitch_connectors/src/connectors/globalpay/transformers.rs` file was examined to understand how the connector maps the `connector_request_reference_id` to the `reference` field in the request and how the `connector_response_reference_id` is populated from the `reference` field in the response.
3.  The code was inspected to confirm that `connector_request_reference_id` is used to populate the `reference` field in the Globalpay request and `connector_response_reference_id` is populated from the `reference` field in the Globalpay response.
4.  The `memory-bank/GlobalPay_connector.md` file was updated with the audit results.

                                         <!-- ----------------------------------------------------- -->

## Audit for unnecessary `set_body()` calls

1.  **Identify the relevant files:** The primary file to examine is the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/globalpay.rs`).
2.  **Look for the `build_request` functions:** Search for the `build_request` functions within the connector's code for each payment flow (e.g., Authorize, Capture, Refund).
3.  **Check for `set_body()` calls:** For each `build_request` function, check if it includes a call to `set_body()`.
4.  **Examine the corresponding `get_request_body` function:** If `set_body()` is present, examine the corresponding `get_request_body` function to determine if it returns a request body.
    *   If `get_request_body` returns an empty request body (e.g., `Ok(RequestContent::Json(Box::new(serde_json::json!({}))))`), then the `set_body()` call in `build_request` is unnecessary and incorrect.
    *   If `set_body()` is NOT present and there is no request body, then the status should be ✅.
5.  **Document the findings:** Update the connector's audit file (e.g., `memory-bank/GlobalPay_connector.md`) with the results of the audit.

**Example: GlobalPay Connector `set_body()` Audit**

In the GlobalPay connector audit, the following steps were taken:

1.  The `crates/hyperswitch_connectors/src/connectors/globalpay.rs` file was examined.
2.  The `build_request` functions for Authorize, Capture, Void, PSync, Refund, RSync, and Complete Authorize were analyzed.
3.  It was found that the Complete Authorize flow included `set_body()`, but the corresponding `get_request_body` function returned an empty JSON object.
4.  The `memory-bank/GlobalPay_connector.md` file was updated to reflect this finding.

During the audit, no specific errors were made, but the process highlighted the importance of carefully examining both the `build_request` and `get_request_body` functions to ensure that `set_body()` is only included when necessary.

                                         <!-- ----------------------------------------------------- -->

## Handle connector_request_reference_id and connector_response_reference_id (check if rsync and psync can be done with connector_request_reference_id/connector_response_reference_id)

1.  **Identify the relevant files:** The primary file to examine is the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/globalpay.rs`) and the transformers file (e.g., `crates/hyperswitch_connectors/src/connectors/globalpay/transformers.rs`).
2.  **Check for the presence of `connector_request_reference_id` :** Search for the usage of `connector_request_reference_id` in the connector's code.
    *   Verify that it is used to populate the `reference` field in the connector's request.
3.  **Check for the presence of `connector_response_reference_id`:** Search for the usage of `connector_response_reference_id` in the connector's code.
    *   Verify if the connector populates the `connector_response_reference_id` from the connector's response.
4.  **Analyze PSync and RSync flows:** Check if rsync and psync can be done with `connector_request_reference_id` and `connector_response_reference_id`.
    *   If `connector_response_reference_id` is not present, check if the `reference` field (populated using `connector_request_reference_id`) can be used for reconciliation in PSync and RSync flows.
    *   Verify if PSync relies on `connector_transaction_id` to construct the URL.
5.  **Document the findings:** Update the connector's audit file (e.g., `memory-bank/GlobalPay_connector.md`) with the results of the audit.

During the audit, the following errors were made:

*   Initially, there were issues with the `replace_in_file` tool due to incorrect search patterns.
*   The audit was not initially performed for every feature (authorize, psync, rsync, capture etc.).

These errors were corrected by:

*   Re-reading the file content to ensure accurate search patterns for `replace_in_file`.
*   Adding a check for every feature in the "Request/Response Reference IDs Audit" section.

                                         <!-- ----------------------------------------------------- -->

### Amount in Request Body Audit

1.  **Identify the connector's main file:** Locate the main file for the connector (e.g., `crates/hyperswitch_connectors/src/connectors/[connector_name].rs`).
2.  **Analyze request body functions:** Identify the functions responsible for building the request body for each payment flow (Authorize, Capture, Refund, Void, etc.). These functions typically have names like `get_request_body`.
3.  **Check for amount parameter:** Within each request body function, verify that the amount parameter is being included in the request body.
4.  **Document findings:** Update the connector's audit file (`memory-bank/[ConnectorName]_connector.md`) with the results of the audit, indicating whether the amount is present in the request body for each feature.

During the Globalpay connector audit, the following steps were taken:

1.  The `crates/hyperswitch_connectors/src/connectors/globalpay.rs` file was examined to understand how the connector handles requests and where the amount is being processed.
2.  The `get_request_body` functions for Authorize, Capture, Refund, and Void were analyzed to check if the amount was being passed in the request body.
3.  The `memory-bank/GlobalPay_connector.md` file was updated with the audit results.

** If the amount is not passed for fields like psync, rsync which retrieves data , so pass N/A as status instead of ❌.

During the audit, no specific errors were made. The process involved identifying the code that handles the amount and verifying that it was being used correctly.

To perform this audit for other connectors, follow these steps:

1.  Identify the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/[connector_name].rs`).
    *   Example: `search_files <path>crates/hyperswitch_connectors/src/connectors/[connector_name]</path> <regex>connector_transaction_id: Some\(response\.(.*)\)</regex>`
*   **Manual Analysis:** Carefully review the code to understand the data flow and mapping logic.

                                         <!-- ----------------------------------------------------- -->

### Currency Unit Handling Audit 
## dev needs to check in the docs for the currency supported 

1.  **Identify the relevant files:** The primary file to examine is the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/globepay.rs`).
2.  **Look for the `convert_amount` function:** Search for the usage of the `convert_amount` function within the connector's code.
3.  **Verify the currency parameter:** Ensure that the `convert_amount` function is called with the correct currency parameter.
4.  **Document the findings:** Update the connector's audit file (e.g., `memory-bank/GlobalPay_connector.md`) with the results of the audit.

During the audit, no specific errors were made. The process involved identifying the `convert_amount` function and verifying that it was being used correctly with the appropriate currency parameter.

                                         <!-- ----------------------------------------------------- -->

### Dynamic Field Audit

### Steps for Dynamic Field Audit

1.  **Identify Supported Payment Methods:** Examine the `ConnectorSpecifications` implementation in the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/[connector_name].rs`) to identify all supported payment methods.

2.  **Identify Required Connector Fields from the Contract:** For each supported payment method, review the `[connector_name].md` file in the `memory-bank` directory. This file serves as the contract, defining which fields are mandatory for the connector's API.

3.  **Trace Field Population in the Transformer:** Open the connector's `transformers.rs` file. For each mandatory field identified in the contract, locate where it is populated in the connector's request struct. Trace the data source back to the function call that provides the value (e.g., `item.router_data.get_billing_country()`).

4.  **Identify the Root Data Path from the Getter Function:** Analyze the implementation of the getter function (e.g., `get_billing_country()`) to determine the precise path of the source data within Hyperswitch's internal data structures. For example, the function `get_billing_country()` might resolve to the path `payment_method_data.billing.address.country`.

5.  **Verify the Root Path in `payment_connector_required_fields.rs`:** Open the `crates/payment_methods/src/configs/payment_connector_required_fields.rs` file. In the `RequiredFields::default()` function, confirm that for the specific connector and payment method being audited, the exact root data path identified in the previous step is listed as a required field. This ensures that Hyperswitch's core logic enforces the presence of this data before it reaches the connector.

6.  **Handle Fallbacks:** If a field has a fallback (e.g., using `customer_name` if available, otherwise falling back to `billing.name`), ensure that both paths or either path are considered and documented in the audit. Write in the audit as well the details.

7.  **Generate Audit Report:** Create a report summarizing the findings for each payment method, confirming that the data path required by the transformer is correctly marked as a required field in the central configuration.

### Common Errors and Corrections for Dynamic Field Audit

1.  **Incorrectly Identifying Supported Payment Methods:**
    *   **Error:** Assuming the payment methods are defined in a separate variable or file.
    *   **Correction:** Always check the `ConnectorSpecifications` implementation in the connector's main file.
2.  **Incorrect `replace_in_file` Usage:**
    *   **Error:** Using incorrect search patterns for `replace_in_file`.
    *   **Correction:** Re-read the file content to ensure accurate search patterns.

### Example: GlobalPay Connector Dynamic Field Audit

In the GlobalPay connector audit, the following steps were taken:

1.  The `crates/hyperswitch_connectors/src/connectors/globalpay.rs` file was examined to understand the supported payment methods.
2.  The `crates/payment_methods/src/configs/payment_connector_required_fields.rs` file was examined to determine if the required fields were mapped for each payment method.
3.  The `RequiredFields::default()` function was analyzed to check if GlobalPay had an entry for each supported payment method.
4.  The field mappings were verified for each supported payment method.
5.  The `memory-bank/GlobalPay_connector.md` file was updated with the audit results.

During the audit, the following errors were made:

*   Initially, I attempted to identify the supported payment methods by looking for a specific variable (e.g., `GLOBALPAY_SUPPORTED_PAYMENT_METHODS`).
*   I incorrectly assumed that the `ConnectorSpecification` was in a separate file.
    *   **Correction:** I was corrected by the user and realized that the `ConnectorSpecification` was implemented in the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/globalpay.rs`).
*   I initially had issues with the `replace_in_file` tool due to incorrect search patterns.
    *   **Correction:** I re-read the file content to ensure accurate search patterns.

                                         <!-- ----------------------------------------------------- -->

## Steps for Auditing Merchant Metadata Handling in Connectors

These steps outline a generic process for auditing how a connector handles merchant metadata. This process can be adapted for other connectors as well.

1.  **Understand the Task:**
    *   The initial task was to create an audit for the handling of merchant metadata in the GlobalPay connector.
    *   The audit should determine if metadata is present and how it's used. If metadata is not present, the audit should indicate "N/A".

2.  **Examine the Connector's Code:**
    *   Identify the relevant files in the connector's codebase. For GlobalPay, the primary files were:
        *   `crates/hyperswitch_connectors/src/connectors/globalpay/transformers.rs`: This file contains the data transformation logic, including how metadata is handled.
        *   `crates/hyperswitch_connectors/src/connectors/globalpay.rs`: This file defines the connector's integration with HyperSwitch, including the `CompleteAuthorize` flow.
        *   `crates/hyperswitch_domain_models/src/router_data.rs`: This file defines the structure of `RouterData` and related structs, which are used to pass data between HyperSwitch and the connector.

3.  **Identify Metadata Usage:**
    *   Analyze the `transformers.rs` file to find how the connector extracts and uses merchant metadata.
    *   Look for code that accesses the `connector_meta_data` field in the `PaymentsAuthorizeRouterData` struct.
    *   In GlobalPay, the `GlobalPayMeta` struct is used to extract the `account_name` from the metadata.

4.  **Determine if Metadata is Optional:**
    *   Check the definition of the `connector_meta_data` field in the `RouterData` struct (in `router_data.rs`) to see if it's an `Option`.
    *   If it's an `Option`, the metadata is optional, and the connector must handle cases where it's absent.

5.  **Audit Each Relevant Flow:**
    *   For each payment flow (e.g., Authorize, Capture, Refund), determine if metadata is used and how it affects the flow.
    *   If metadata is not used in a particular flow, mark it as "N/A" in the audit.
    *   In GlobalPay, metadata (specifically, the `account_name`) is used in the `Authorize` flow.

6.  **Address Errors and Feedback:**
    *   The `replace_in_file` tool was initially used to add the audit section to the `GlobalPay_connector.md` file, but it failed due to formatting issues. The `write_to_file` tool was used as a fallback.
    *   The user provided feedback that the audit section incorrectly stated that metadata was present in all flows. This was corrected by analyzing the code and marking the appropriate flows as "N/A".
    *   The user also pointed out that the audit section didn't explicitly state how the `account_name` was extracted from the metadata. This was corrected by adding a note to the `Authorize` flow.
    *   Finally, the user asked how it was determined that the `connector_meta_data` field is optional. This was corrected by examining the definition of the `RouterData` struct and confirming that the field is an `Option`.

7.  **Document Findings:**
    *   Create a table in the `GlobalPay_connector.md` file to summarize the audit findings.
    *   Include the following columns:
        *   Feature: The payment flow being audited (e.g., Authorize, Capture, Refund).
        *   Status: A checkmark (✅) if metadata is used, "N/A" if it's not applicable.
        *   Notes: A brief explanation of how metadata is used or why it's not applicable.

8.  **Generalization for Other Connectors:**
    *   This process can be generalized for other connectors by following these steps:
        1.  Identify the relevant files in the connector's codebase.
        2.  Look for code that accesses metadata or configuration data.
        3.  Determine if the data is optional and how the connector handles cases where it's absent.
        4.  Audit each relevant flow to see how the data affects the flow.
        5.  Document the findings in a clear and concise manner.

By following these steps, you can effectively audit the handling of merchant metadata in any connector and ensure that it's implemented correctly.

                                         <!-- ----------------------------------------------------- -->

## config changes audit
## Steps for Auditing Base URL Configuration in Connectors

These steps outline a generic process for auditing the base URL configuration in connectors. This process can be adapted for other connectors as well.

1.  **Identify the Task:**
    *   The initial task was to create an audit to check for config changes for the Globalpay connector.
    *   The audit should determine if the base URL is present in the following TOML files: `config.example.toml`, `integration_test.toml`, `production.toml`, `sandbox.toml`, `development.toml`, and `docker_compose.toml`.

2.  **Examine the Configuration Files:**
    *   Use the `read_file` tool to read the contents of each TOML file.
    *   Search for the connector's base URL within each file. The base URL is typically defined in the `[connectors]` section of the TOML file.

3.  **Document Findings:**
    *   Create a table in the `[connector_name]_connector.md` file to summarize the audit findings.
    *   Include the following columns:
        *   File: The name of the TOML file being audited.
        *   Status: A checkmark (✅) if the base URL is present, or a cross (❌) if it's missing.

4.  **Address Errors and Feedback:**
    *   The `read_file` tool initially failed because the `integration_test.toml` file was not found in the current working directory. This was corrected by using the `list_files` tool to locate the file in the `config/deployments` directory.
    *   The audit was not initially performed for every TOML file. This was corrected by adding a check for each file in the "Base URL Audit" section.
    *   The `replace_in_file` tool was initially used to add the audit section to the `GlobalPay_connector.md` file, but it failed due to formatting issues. The `write_to_file` tool was used as a fallback.

5.  **Generalization for Other Connectors:**
    *   This process can be generalized for other connectors by following these steps:
        1.  Identify the relevant TOML configuration files.
        2.  Use the `read_file` tool to read the contents of each file.
        3.  Search for the connector's base URL within each file.
        4.  Document the findings in a clear and concise manner.

By following these steps, you can effectively audit the base URL configuration in any connector and ensure that it's implemented correctly.

                                         <!-- ----------------------------------------------------- -->

## Steps for Auditing Sandbox and Production endpoint 

These steps outline a generic process for auditing the sandbox and production endpoint in connectors. This process can be adapted for other connectors as well.

1.  **Identify the Task:**
    *   The initial task was to create an audit to check for sandbox and production endpoints for the Globalpay connector.
    *   The audit should determine the endpoint for that connector in the below toml files: `production.toml`, `sandbox.toml`.

2.  **Examine the Configuration Files:**
    *   Use the `list_files` tool to list the files in the `config` directory.
    *   Use the `read_file` tool to read the contents of each TOML file.
    *   Search for the connector's base URL within each file. The base URL is typically defined in the `[connectors]` section of the TOML file.

3.  **Document Findings:**
    *   Create a table in the `[connector_name]_connector.md` file to summarize the audit findings.
    *   Include the following columns:
        *   File: The name of the TOML file being audited.
        *   Endpoint: The base URL found in the file.

4.  **Address Errors and Feedback:**
    *   The `read_file` tool initially failed because the `production.toml` file was not found in the `config` directory. This was corrected by listing the files in the `config` directory and identifying the correct file names (`config.example.toml` and `development.toml`).
    *   The `search_files` tool was used to find the `globalpay.base_url` in the config files.

5.  **Generalization for Other Connectors:**
    *   This process can be generalized for other connectors by following these steps:
        1.  Identify the relevant TOML configuration files.
        2.  Use the `list_files` tool to list the files in the `config` directory.
        3.  Use the `read_file` tool to read the contents of each file.
        4.  Search for the connector's base URL within each file.
        5.  Document the findings in a clear and concise manner.

By following these steps, you can effectively audit the base URL configuration in any connector and ensure that it's implemented correctly.

                                         <!-- ----------------------------------------------------- -->

## Response Struct Field Value should be a secret Audit

## Steps for Response Struct Field Value Audit

1.  **Identify response structs:** Examine the connector code and identify the files that contain response structs (e.g., `response.rs`, `transformers.rs`).
2.  **Read the contents of the response files:** Use `read_file` to read the contents of the identified files.
3.  **Analyze the response structs:** Examine the connector code and identify the files that contain response structs (e.g., `response.rs`, `transformers.rs`). Check if fields containing sensitive information (e.g., card numbers, CVV, etc.) are properly masked using the `#[serde(skip_serializing)]` attribute or other appropriate mechanisms like `masking::Secret`. If all sensitive fields are handled correctly, mark the audit as successful. If there are any specific fields that are not handled correctly, mention them explicitly in the audit.

                                         <!-- ----------------------------------------------------- -->

## Check API Contracts Audit

### 1. Understand the API Contract

*   **Locate the Contract File:** Find the markdown file in the `memory-bank` directory that corresponds to the connector being audited (e.g., `memory-bank/[connector_name].md`). This file serves as the local representation of the connector's API contract.
*   **Identify Supported Payment Methods and Required Fields:** Read the contract file to determine the payment methods the connector supports and identify all fields that are not marked as optional for each flow (e.g., Payment Intent, Confirm Intent, etc.).

### 2. Verify Implementation in Transformers

*   **Examine the `transformers.rs` File:** Open the `transformers.rs` file for the connector, located at `crates/hyperswitch_connectors/src/connectors/[connector_name]/transformers.rs`.
*   **Cross-Reference with Contract:** Compare the payment methods and their required fields as documented in the markdown file with the implementation in the `transformers.rs` file.
*   **Check for Non-Optional Fields:** For every field that is mandatory according to the contract, ensure that the corresponding field in the Rust structs is not wrapped in an `Option`. This enforces the contract at compile time.
*   **Check Request Construction:** Ensure that for each payment flow (e.g., Authorize, Capture, Refund), the correct payment method information is being included in the outgoing request to the connector's API. This includes verifying that all required fields for each flow are correctly populated.
*   **Detailed Analysis:** Provide a detailed analysis for each payment method, including the specific structs and fields that were audited. For example, for a payment intent, list all the fields in the request struct and verify that they are correctly implemented.

### 3. Example: Airwallex Connector API Contract Audit

In the Airwallex connector audit, the following steps were taken:

1.  The `memory-bank/airwallex.md` file was read to identify the supported payment methods and their required fields.
2.  The `crates/hyperswitch_connectors/src/connectors/airwallex/transformers.rs` file was examined.
3.  The implementation of payment methods like Cards, Google Pay, and Klarna in the `transformers.rs` file was compared against the documentation in `airwallex.md`.
4.  It was verified that all required fields are present in the request structs and are not wrapped in `Option`.
5.  The data mapping logic was analyzed to confirm that the fields are populated correctly.
6.  **Result:** The audit confirmed that the `airwallex` connector correctly and robustly implements the API contracts as specified in the documentation.

                                         <!-- ----------------------------------------------------- -->

## Steps for Auditing MCA Metadata Handling in Connectors

These steps outline the process for auditing how a connector handles MCA (Merchant Category Code) metadata. This process can be adapted for other connectors as well.

1.  **Understand the Task:**
    *   The primary goal is to audit the connector's code to determine if and how it handles MCA metadata.
    *   MCA metadata typically involves validating the merchant's account name against a list of approved account names.

2.  **Examine the Connector's Code:**
    *   Identify the relevant files in the connector's codebase. For GlobalPay, the primary file was:
        *   `crates/hyperswitch_connectors/src/connectors/globalpay/transformers.rs`: This file contains the data transformation logic, including how metadata is handled.

3.  **Identify Metadata Usage:**
    *   Analyze the `transformers.rs` file to find how the connector extracts and uses merchant metadata.
    *   Look for code that accesses the `connector_meta_data` field in the `PaymentsAuthorizeRouterData` struct.
    *   In GlobalPay, the `GlobalPayMeta` struct is used to extract the `account_name` from the metadata.

4.  **Determine if Metadata is Optional:**
    *   Check the definition of the `connector_meta_data` field in the `RouterData` struct (typically in `crates/hyperswitch_domain_models/src/router_data.rs`) to see if it's an `Option`.
    *   If it's an `Option`, the metadata is optional, and the connector must handle cases where it's absent.

5.  **Audit Each Relevant Flow:**
    *   For each payment flow (e.g., Authorize, Capture, Refund), determine if metadata is used and how it affects the flow.
    *   If metadata is not used in a particular flow, mark it as "N/A" in the audit.
    *   In GlobalPay, metadata (specifically, the `account_name`) is used in the `Authorize` flow.

6.  **Document Findings:**
    *   Create a table in the `[ConnectorName]_connector.md` file to summarize the audit findings.
    *   Include the following columns:
        *   Feature: The payment flow being audited (e.g., Authorize, Capture, Refund).
        *   Status: A checkmark (✅) if metadata is used, "N/A" if it's not applicable.
        *   Notes: A brief explanation of how metadata is used or why it's not applicable.

7.  **Errors and Corrections:**
    *   During the audit, I initially did not fully understand the purpose of MCA metadata validation.
        *   **Correction:** I asked the user for clarification on what MCA metadata validation entails.
    *   I also needed to identify the specific code responsible for extracting the account name from the metadata.
        *   **Correction:** I examined the `transformers.rs` file to locate the code that accesses the `connector_meta_data` field and extracts the `account_name`.

By following these steps, you can effectively audit the handling of MCA metadata in any connector and ensure that it's implemented correctly.

                                         <!-- ----------------------------------------------------- -->


# General Connector Audit Workflow Template for response codes.

## 1. Audit Objective
To systematically test and verify the integration of a Hyperswitch connector, ensuring it correctly handles various payment flows and gracefully manages different success/error scenarios. This audit aims to confirm that Hyperswitch consistently interacts with the connector and processes responses according to expected behavior across four key outcome categories.

## 2. Scope
This workflow applies to any payment connector integrated with Hyperswitch. The specific payment methods and flows tested will depend on the capabilities of the individual connector being audited.

## 3. Key Outcome Scenarios to Test for Each Flow:
For each primary payment/refund flow, the following four outcome scenarios will be targeted:
1.  **Case 1: 200 OK (Connector Success):** Hyperswitch receives a successful response from the connector.
2.  **Case 2: 200 OK (Connector Failure with error_message):** 
3.  **Case 3: 4xx Client Error (Hyperswitch Validation/Request Error):** The request to Hyperswitch is invalid (e.g., missing fields, bad data types) and is rejected by Hyperswitch before reaching the connector.
4.  **Case 4: 5xx Server Error (Internal Server Error):** for the 5xx server error, you just have to check in the code for the connector file and for that flow for which you are checking , if we have the function get_5xx_error_response explicitly mentioned , audit it as Yes case and if we do not have that function ,check for get_error_response function and if present audit it as Default.

## 4. Pre-requisites for Starting an Audit on a Connector:
*   Access to the Hyperswitch instance (e.g., `http://localhost:8080`).
*   Valid Hyperswitch Admin API Key for merchant/connector setup.
*   Valid Hyperswitch Merchant API Key for payment operations.
*   Test credentials for the target connector's sandbox environment.
*   Access to the connector's `ConnectorSpecification` source file (e.g., `crates/hyperswitch_connectors/src/connectors/[connector_name].rs`).
*   Access to the connector's `transformers.rs` source file.
*   Access to Hyperswitch's OpenAPI specification (`api-reference/openapi_spec.json`).
    *   (Optional but helpful) Connector's sandbox documentation (for error triggers).
    *   The dummy card details required for testing payments can be retrieved from `cypress-tests/cypress/e2e/configs/Payment/[connector_name].js`.

## 5. Audit Phases & Steps:

### Phase A: Preparation & Information Gathering (PLAN MODE with Cline)
1.  **A.1. Identify Target Connector:** User specifies the connector to audit (e.g., "Stripe", "Adyen", "Fiserv").

2.  Create curl for merchant account and then curl for create api key and execute the command so you'll have the merchant id , api key etc.
    **A.2. Gather Connector-Specific Information (Cline with `read_file`):**
    *   Read the connector's `ConnectorSpecification` file.
    *   Extract:
        *   Supported Payment Methods (e.g., Card, Bank Redirect).
        *   Supported Payment Method Types (e.g., Credit, Debit, iDEAL).
        *   Supported Flows (Authorize, Capture, PSync, Void, Refund Execute, Refund Sync, etc.).
        *   Any specific features or limitations.
    *   Read the connector's `transformers.rs` file.
    *   Identify:
        *   Required `connector_account_details` structure for setup.
        *   Any mandatory metadata expected during connector setup or in payment requests (e.g., `terminal_id` for Fiserv).
        *   How connector-specific errors are handled and mapped.
3.  **A.3. Gather Test Credentials & Environment Details (User provides):**
    *   User provides test sandbox credentials for the target connector.
    *   User confirms the Hyperswitch API base URL for testing.
    *   Cline retrieves dummy card numbers and other test data from the connector's test file, located at `cypress-tests/cypress/e2e/configs/Payment/[connector_name].js`.
4.  **A.4. Create Connector-Specific Test Plan Document (Cline, in ACT MODE, will generate `memory-bank/connector_test_plan_[connector_name].md`):**
    *   This document will be an instantiation of this general workflow, listing all applicable Payment Methods, Flows, and the 4 Scenarios for the *specific connector*.
    *   For each scenario, outline the cURL formulation strategy (e.g., "Omit field X", "Use test card Y known to cause decline Z").
5.  **A.5. Prepare Logging Document (Cline, in ACT MODE, will generate `memory-bank/[connector_name]_test_logs.md`).**

### Phase B: Setup Hyperswitch Test Environment following the below steps in order for each section (Executes cURLs formulated by Cline)
1.  **B.1. Create Test Merchant Account:**

    *   Cline formulates cURL for `POST /accounts` and executes.
    *   **Sample cURL:**
        ```bash
        curl --location 'http://localhost:8080/accounts' \
        --header 'Content-Type: application/json' \
        --header 'Accept: application/json' \
        --header 'api-key: test_admin' \
        --data '{
            "merchant_id": "merchant_{{$timestamp}}",
            "merchant_name": "john doe",
            "return_url": "https://google.com",
            "primary_business_details": [        
                {
                    "country": "US",
                    "business": "default"
                }
            ]
        }'
        ```

    *   Cline reads the response from the terminal and appends the `merchant_id` and `profile_id` to the log file created for that connector, ensuring that existing data is not overwritten.

2.  **B.2. Create API Key for the Merchant:**
    *   Cline formulates the cURL for creating an API key using the `merchant_id` obtained in the previous step.
    *   **Sample cURL:**
        ```bash
        curl --location 'http://localhost:8080/api-keys/:merchant_id' \
        --header 'Content-Type: application/json' \
        --header 'Accept: application/json' \
        --header 'api-key: test_admin' \
        --data '{
          "name": "API Key 2",
          "description": null,
          "expiration": "2038-01-19T03:14:08.000Z"
        }'
        ```
    *   Cline executes the cURL, reads the response from the terminal, and appends the new `api_key` to the log file. This key will be used for subsequent payment-related API calls.
    *   Cline logs these details in `activeContext.md` and potentially a `[connector_name]_test_environment.md`.

3.  **B.3. Add Target Connector to Merchant Account:**
    *   Cline formulates cURL for `POST /account/{account_id}/connectors`, including:
        *   **Sample cURL: **
            curl --location 'http://localhost:8080/account/{account_id}/connectors' \
            --header 'Content-Type: application/json' \
            --header 'Accept: application/json' \
            --header 'api-key: dev_roYwlEcXHql9GpUP5GnNnxeKNDGusfoaDN2KxxMSfS0SGavjr3il0wsB2Cs3OIg6' \
            --data '{
                "connector_type": "payment_processor",
                "connector_name": "airwallex",
                "connector_account_details": {
                    ...
                },
                "test_mode": true,
                "payment_methods_enabled": [
                {
                    "payment_method": "card",
                    "payment_method_types": [
                        {
                            "payment_method_type": "credit",
                            "card_networks": [
                                "Visa",
                                "Mastercard"
                            ],
                            "minimum_amount": 1,
                            "maximum_amount": 68607706,
                            "recurring_enabled": true,
                            "installment_payment_enabled": true 
                        },
                        {
                            "payment_method_type": "debit",
                            "card_networks": [
                                "Visa",
                                "Mastercard"
                            ],
                            "minimum_amount": 1,
                            "maximum_amount": 68607706,
                            "recurring_enabled": true,
                            "installment_payment_enabled": true                    
                        }
                    ]
                },
                {
                    "payment_method": "wallet",
                    "payment_method_types": [
                        {
                            "payment_method_type": "paypal",
                            "payment_experience": "redirect_to_url",
                            "minimum_amount": 1,
                            "maximum_amount": 68607706,
                            "recurring_enabled": false,
                            "installment_payment_enabled": true
                        }
                    ]
                },
                {
                    "payment_method": "pay_later",
                    "payment_method_types": [
                        {
                            "payment_method_type": "klarna",
                            "payment_experience": "redirect_to_url",
                            "card_networks": null,
                            "accepted_currencies": null,
                            "accepted_countries": null,
                            "minimum_amount": 0,
                            "maximum_amount": 68607706,
                            "recurring_enabled": false,
                            "installment_payment_enabled": false
                        },
                        {
                            "payment_method_type": "atome",
                            "payment_experience": "redirect_to_url",
                            "card_networks": null,
                            "accepted_currencies": null,
                            "accepted_countries": null,
                            "minimum_amount": 0,
                            "maximum_amount": 68607706,
                            "recurring_enabled": false,
                            "installment_payment_enabled": false
                        }
                    ]
                },
                {
                    "payment_method": "bank_redirect",
                    "payment_method_types": [
                        {
                            "payment_method_type": "blik",
                            "payment_experience": null,
                            "card_networks": null,
                            "accepted_currencies": null,
                            "accepted_countries": null,
                            "minimum_amount": 0,
                            "maximum_amount": 68607706,
                            "recurring_enabled": false,
                            "installment_payment_enabled": false
                        },
                        {
                            "payment_method_type": "trustly",
                            "payment_experience": null,
                            "card_networks": null,
                            "accepted_currencies": null,
                            "accepted_countries": null,
                            "minimum_amount": 0,
                            "maximum_amount": 68607706,
                            "recurring_enabled": false,
                            "installment_payment_enabled": false
                        }  
                    ]
                }  
                ],
                "connector_webhook_details": {
                    "merchant_secret": "MyWebhookSecret"
                },
                "business_country": "US",
                "business_label": "default"
            }'
        *   in the headers , use the api_key obtained in the B.2.
        *   Connector name, type.
        *   `connector_account_details` populated with user-provided test credentials for the connector.
        *   Any connector-specific `metadata` identified in A.2. Find all the supported payment methods and payment method types, and enable them like done in the sample curl.
        *   **Note on Mandates:** For each payment method, check if mandates are supported in the connector's main file (e.g., `crates/hyperswitch_connectors/src/connectors/[connector_name].rs`). Set `"recurring_enabled": true` if `mandates: enums::FeatureStatus::Supported` and `false` otherwise.
    *   Cline executes and reads the response from the terminal.
    *   Cline appends the details to the log file created for that connector.
    *   **Note on Credentials:** Before making this call, always ask the user to provide the credentials for `connector_account_details`.

### Phase C: Comprehensive Test Execution for a Single Payment Method
This phase focuses on exhaustively testing a single payment method type to validate all possible outcomes.

1.  **C.1. Select Primary Payment Method:** From the list of supported payment methods, select one to be the primary candidate for comprehensive testing.
2.  **C.2. Iterate Through Flows and Scenarios:** For the selected payment method, iterate through each supported flow (e.g., Authorize, Capture, Refund) and execute tests for all four outcome scenarios:
    *   **200 OK (Success):** A successful transaction.
    *   **200 OK (Failure):** A failed transaction with an error message.
    *   **4xx Client Error:** An invalid request from the client.
    *   **5xx Server Error:** An internal server error.
    *   **Note:** For the first payment method, all four scenarios should be tested for all flows.

    **Testing Payments with Capture:**

    When testing payment flows, it's crucial to validate both `automatic` and `manual` capture methods if the connector supports them.

    *   **Automatic Capture:**
        *   Formulate a payment request with `"capture_method": "automatic"`.
        *   Execute the cURL. The payment should be authorized and captured in a single step.
        *   **Sample cURL portion:**
            ```json
            {
                "capture_method": "automatic",
                ...
            }
            ```

    *   **Manual Capture:**
        *   **Step 1: Create a Payment with Manual Capture:**
            *   Formulate a payment request with `"capture_method": "manual"`.
            *   Execute the cURL. This will only authorize the payment.
            *   Log the `payment_id` from the response.
            *   **Sample cURL portion:**
                ```json
                {
                    "capture_method": "manual",
                    ...
                }
                ```
        *   **Step 2: Capture the Payment:**
            *   Formulate a cURL for the `POST /payments/{payment_id}/capture` endpoint.
            *   Use the `payment_id` obtained in the previous step.
            *   Execute the cURL to capture the funds.
            *   **Sample cURL:**
                ```bash
                curl --location 'http://localhost:8080/payments/:payment_id/capture' \
                --header 'Content-Type: application/json' \
                --header 'api-key: your_api_key' \
                --data '{}'
                ```

3.  **C.3. Formulate and Execute cURL:** For each scenario, formulate the appropriate cURL command and execute it against the Hyperswitch instance.
    *   **Note on Country and Currency:** When formulating the cURL for making payments, the `country` and `currency` should be sourced from the `config/development.toml` file. Look for the `[pm_filters.connector_name]` section for the specific connector being audited. Within that section, find the relevant payment method (e.g., `debit`, `credit`) and use the corresponding `country` and `currency` values. For example, for a debit card payment with the `airwallex` connector, you would look under `[pm_filters.airwallex]` for the `debit` payment method to find the appropriate values.
4.  **C.4. Log and Update:** Log the results of each test in `[connector_name]_test_logs.md`, update the status in `connector_test_plan_[connector_name].md`, and record progress in `progress.md`.

### Phase D: Success-Scenario Testing for Remaining Payment Methods
This phase ensures that all other supported payment methods are tested for the success scenario (2xx).

1.  **D.1. Iterate Through Remaining Payment Methods:** For each of the remaining payment method types, iterate through all supported flows.
2.  **D.2. Formulate and Execute cURL for Success Scenario:** For each flow, formulate and execute a cURL command designed to produce a successful (2xx) outcome.
    *   **Note:** For the remaining payment methods, only the 200 OK (Success) scenario needs to be tested for all flows.
3.  **D.3. Log and Update:** Log the results of each test in `[connector_name]_test_logs.md`, update the status in `connector_test_plan_[connector_name].md`, and record progress in `progress.md`.

### Phase E: Review & Completion
1.  **E.1. Review Test Plan:** Once all test cases are completed, review `connector_test_plan_[connector_name].md` for any failures or skipped tests.
2.  **E.2. Analyze Logs:** Review `[connector_name]_test_logs.md` for any anomalies or unexpected behavior.
3.  **E.3. Summarize Findings:** Cline can help summarize the audit results based on the Memory Bank.
4.  **E.4. Archive/Conclude:** Mark the audit as complete in `progress.md`.

## 6. Memory Bank Files for a Specific Connector Audit:
*   `memory-bank/projectbrief.md` (Overall project context)
*   `memory-bank/productContext.md` (Overall project context)
*   `memory-bank/systemPatterns.md` (Overall project context)
*   `memory-bank/techContext.md` (Overall project context)
*   `memory-bank/activeContext.md` (Dynamically updated during the audit)
*   `memory-bank/progress.md` (Dynamically updated during the audit)
*   `memory-bank/connector_audit_workflow_template.md` (This general template)
*   `memory-bank/connector_test_plan_[connector_name].md` (Specific instance for the audited connector)
*   `memory-bank/[connector_name]_test_logs.md` (Specific logs for the audited connector)
*   (Optional) `memory-bank/[connector_name]_test_environment.md` (To store `merchant_id`, `profile_id`, API keys used for the audit)

                                         <!-- ----------------------------------------------------- -->

## Creating an Audit File for a Connector

These steps outline how to create an audit file for any connector :
1.  **Create a new file:** Create a new markdown file in the `memory-bank` directory named `[ConnectorName]_connector.md`.
2.  **Add a title:** Add a title to the file, such as `# [ConnectorName] Connector Audit`.
3.  **Add sections for each audit area:** Add sections for each area you want to audit, such as:
    *   Currency Unit Handling Audit
    *   Status Mapping Audit
    *   Reconcile with Reference ID Audit
    *   Audit for Handle connector_request_reference_id and connector_response_reference_id
    *   Audit for unnecessary set_body() calls
    *   Amount in Request Body Audit
    *   Dynamic Fields Audit
    *   Handling of merchant metadata if metadata is present
    *   Config changes Audit
    *   Endpoint Audit
    *   Response Struct Field Value Audit
    *   MCA metadata validation
    *   Check API Contracts
    *   Response code Audit - for this refer to the section "# General Connector Audit Workflow Template for response codes." in this file

4.  **For each section, create a log entry:** Create a log entry with the following information:
    *   **Test Case:** The payment method, flow, and scenario being tested (e.g., Card - Authorize - 200 OK (Success)).
    *   **cURL Command:** The cURL command used to execute the test.
    *   **Response:** The response from the server.
    *   **Status:** The status of the test (e.g., Success, Failure, Requires Customer Action).
5.  **Examine the connector's code:** For each feature, examine the connector's code to determine if it's implemented correctly.
6.  **Document your findings:** In the "Notes" column, document your findings, including the files and code you examined.
7.  **Address errors and feedback:** If you find any errors, document them in the "Notes" column and explain how you corrected them.
8.  **Generalize for other connectors:** If possible, generalize your findings for other connectors.

Once you are done with the auditing of the above fields , do the audit for response codes following the steps in the # General Connector Audit Workflow Template for response codes written in the file.

By following these steps, you can effectively create an audit file for any connector and ensure that it's implemented correctly.
